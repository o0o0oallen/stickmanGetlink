[1,["b1w1pjENlOZ7nujh7mUUkZ"],["_effectAsset"],[["cc.Material",["_name","_techniqueData"],1],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,3],[1,0,1,2,4]],[[[[0,"火2",{"0":{"defines":{"USE_TEXTURE":true}}}]],0,0,[0],[0],[0]],[[[1,"火2",[{"hash":1097620862,"record":null,"name":"火2|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\n  in vec4 v_color;\n  #if USE_TEXTURE\n  in vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\n  #if USE_TARGET\n  uniform sampler2D targetTex;\n  #endif\n  uniform ubo {\n    vec4 targetXYWH;\n    vec4 targetRect;\n    vec4 selfXYWH;\n    vec4 selfRect;\n    vec4 spSlice;\n    vec4 selfSlice;\n    vec4 color1;\n    vec4 color2;\n    float ran;\n    float dirX;\n    float dirY;\n    float dirZ;\n  };\n  vec4 getColor(vec2 uv0) {\n    vec4 o = vec4(1, 1, 1, 1);\n    #if USE_TARGET\n  vec4 targetTex_tmp = texture(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw);\n  #if CC_USE_ALPHA_ATLAS_targetTex\n      targetTex_tmp.a *= texture(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (targetTex_tmp.rgb * targetTex_tmp.rgb);\n    o.a *= targetTex_tmp.a;\n  #else\n    o *= targetTex_tmp;\n  #endif\n    #elif USE_TEXTURE\n  vec4 texture_tmp = texture(texture, uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture(texture, uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n    #endif\n    return o;\n  }\nfloat noise(vec3 p)\n{\n  vec3 i = floor(p);\n  vec4 a = dot(i, vec3(1.0, 57.0, 21.0)) + vec4(0.0, 57.0, 21.0, 78.0);\n  vec3 f = cos((p - i) * acos(-1.0)) * (-0.5) + 0.5;\n  a = mix(sin(cos(a) * a), sin(cos(1.0 + a) * (1.0 + a)), f.x);\n  a.xy = mix(a.xz, a.yw, f.y);\n  return mix(a.x, a.y, f.z);\n}\nfloat sphere(vec3 p, vec4 spr)\n{\n  return length(spr.xyz - p) - spr.w;\n}\nfloat flame(vec3 p)\n{\n  float d = sphere(p * vec3(1.0, 0.5, 1.0), vec4(0.0, -1.0, 0.0, 1.0));\n  return d + (noise(p + vec3(0.0, cc_time.x * 2.0, 0.0)) + noise(p * 3.0) * 0.5) * 0.25 * p.y;\n}\nfloat scene(vec3 p)\n{\n  return min(100.-length(p) , abs(flame(p)) );\n}\nvec4 raymarch(vec3 org, vec3 dir)\n{\n  float glow = 0.0;\n  vec3 p = org;\n  bool glowed = false;\n  for(int i = 0; i < 64; i++)\n  {\n    float d = scene(p);\n    p += (d + 0.02) * dir;\n    if (d > 0.0)\n    {\n      if (flame(p) < 0.0) glowed = true;\n      if (glowed) glow = float(i) / 64.0;\n    }\n  }\n  return vec4(p, glow);\n}\n  void main () {\n    vec4 o = getColor(v_uv0);\n    vec2 realUV0 = (v_uv0 - selfXYWH.xy) / selfXYWH.zw;\n    vec2 realUV = realUV0;\n#if USE_SLICE\n    realUV = ((realUV - 0.0) / (spSlice.xy - 0.0) * (selfSlice.xy - 0.0) + 0.0) * step(realUV, spSlice.xy)\n      + ((realUV - spSlice.xy) / (spSlice.zw - spSlice.xy) * (selfSlice.zw - selfSlice.xy) + selfSlice.xy) * (step(spSlice.xy, realUV) - step(spSlice.zw, realUV))\n      + ((realUV - spSlice.zw) / (1.0 - spSlice.zw) * (1.0 - selfSlice.zw) + selfSlice.zw) * step(spSlice.zw, realUV.xy)\n    ;\n#endif\n  vec2 v = -1.0 + 2.0 * realUV;\n  v.x *= selfRect.z/selfRect.w;\n  vec3 org = vec3(0.0, -2.0, 4.0);\n  vec3 dir = normalize(vec3(v.x * dirX, v.y * dirY, dirZ));\n  vec4 p = raymarch(org, dir);\n  vec4 col = mix(color1, color2, p.y * 0.02 + 0.4);\n  vec4 _o = mix(vec4(0, 0, 0, 0), col, pow(p.w * 2.0, 4.0));\n  _o = vec4(step(noise(vec3(realUV * dirX, cc_time.x)), 1.0));\n    #if SHOW_TARGET\n      o.xyz += _o.xyz * _o.w;\n    #else\n      o.xyz = _o.xyz;\n      o.a *= _o.w;\n    #endif\n    o *= v_color;\n    ALPHA_TEST(o);\n    gl_FragColor = o;\n  }"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform vec4 cc_time;\n  varying vec4 v_color;\n  #if USE_TEXTURE\n  varying vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\n  #if USE_TARGET\n  uniform sampler2D targetTex;\n  #endif\n  uniform vec4 targetXYWH;\nuniform vec4 targetRect;\nuniform vec4 selfXYWH;\nuniform vec4 selfRect;\nuniform vec4 spSlice;\nuniform vec4 selfSlice;\nuniform vec4 color1;\nuniform vec4 color2;\nuniform float dirX;\nuniform float dirY;\nuniform float dirZ;\n  vec4 getColor(vec2 uv0) {\n    vec4 o = vec4(1, 1, 1, 1);\n    #if USE_TARGET\n  vec4 targetTex_tmp = texture2D(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw);\n  #if CC_USE_ALPHA_ATLAS_targetTex\n      targetTex_tmp.a *= texture2D(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (targetTex_tmp.rgb * targetTex_tmp.rgb);\n    o.a *= targetTex_tmp.a;\n  #else\n    o *= targetTex_tmp;\n  #endif\n    #elif USE_TEXTURE\n  vec4 texture_tmp = texture2D(texture, uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture2D(texture, uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n    #endif\n    return o;\n  }\nfloat noise(vec3 p)\n{\n  vec3 i = floor(p);\n  vec4 a = dot(i, vec3(1.0, 57.0, 21.0)) + vec4(0.0, 57.0, 21.0, 78.0);\n  vec3 f = cos((p - i) * acos(-1.0)) * (-0.5) + 0.5;\n  a = mix(sin(cos(a) * a), sin(cos(1.0 + a) * (1.0 + a)), f.x);\n  a.xy = mix(a.xz, a.yw, f.y);\n  return mix(a.x, a.y, f.z);\n}\nfloat sphere(vec3 p, vec4 spr)\n{\n  return length(spr.xyz - p) - spr.w;\n}\nfloat flame(vec3 p)\n{\n  float d = sphere(p * vec3(1.0, 0.5, 1.0), vec4(0.0, -1.0, 0.0, 1.0));\n  return d + (noise(p + vec3(0.0, cc_time.x * 2.0, 0.0)) + noise(p * 3.0) * 0.5) * 0.25 * p.y;\n}\nfloat scene(vec3 p)\n{\n  return min(100.-length(p) , abs(flame(p)) );\n}\nvec4 raymarch(vec3 org, vec3 dir)\n{\n  float glow = 0.0;\n  vec3 p = org;\n  bool glowed = false;\n  for(int i = 0; i < 64; i++)\n  {\n    float d = scene(p);\n    p += (d + 0.02) * dir;\n    if (d > 0.0)\n    {\n      if (flame(p) < 0.0) glowed = true;\n      if (glowed) glow = float(i) / 64.0;\n    }\n  }\n  return vec4(p, glow);\n}\n  void main () {\n    vec4 o = getColor(v_uv0);\n    vec2 realUV0 = (v_uv0 - selfXYWH.xy) / selfXYWH.zw;\n    vec2 realUV = realUV0;\n#if USE_SLICE\n    realUV = ((realUV - 0.0) / (spSlice.xy - 0.0) * (selfSlice.xy - 0.0) + 0.0) * step(realUV, spSlice.xy)\n      + ((realUV - spSlice.xy) / (spSlice.zw - spSlice.xy) * (selfSlice.zw - selfSlice.xy) + selfSlice.xy) * (step(spSlice.xy, realUV) - step(spSlice.zw, realUV))\n      + ((realUV - spSlice.zw) / (1.0 - spSlice.zw) * (1.0 - selfSlice.zw) + selfSlice.zw) * step(spSlice.zw, realUV.xy)\n    ;\n#endif\n  vec2 v = -1.0 + 2.0 * realUV;\n  v.x *= selfRect.z/selfRect.w;\n  vec3 org = vec3(0.0, -2.0, 4.0);\n  vec3 dir = normalize(vec3(v.x * dirX, v.y * dirY, dirZ));\n  vec4 p = raymarch(org, dir);\n  vec4 col = mix(color1, color2, p.y * 0.02 + 0.4);\n  vec4 _o = mix(vec4(0, 0, 0, 0), col, pow(p.w * 2.0, 4.0));\n  _o = vec4(step(noise(vec3(realUV * dirX, cc_time.x)), 1.0));\n    #if SHOW_TARGET\n      o.xyz += _o.xyz * _o.w;\n    #else\n      o.xyz = _o.xyz;\n      o.a *= _o.w;\n    #endif\n    o *= v_color;\n    ALPHA_TEST(o);\n    gl_FragColor = o;\n  }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"USE_TARGET","type":"boolean","defines":[]},{"name":"CC_USE_ALPHA_ATLAS_targetTex","type":"boolean","defines":["USE_TARGET"]},{"name":"INPUT_IS_GAMMA","type":"boolean","defines":["USE_TARGET"]},{"name":"CC_USE_ALPHA_ATLAS_texture","type":"boolean","defines":["USE_TEXTURE"]},{"name":"USE_SLICE","type":"boolean","defines":[]},{"name":"SHOW_TARGET","type":"boolean","defines":[]}],"blocks":[{"name":"ALPHA_TEST","binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"ubo","binding":1,"members":[{"name":"targetXYWH","type":16,"count":1},{"name":"targetRect","type":16,"count":1},{"name":"selfXYWH","type":16,"count":1},{"name":"selfRect","type":16,"count":1},{"name":"spSlice","type":16,"count":1},{"name":"selfSlice","type":16,"count":1},{"name":"color1","type":16,"count":1},{"name":"color2","type":16,"count":1},{"name":"ran","type":13,"count":1},{"name":"dirX","type":13,"count":1},{"name":"dirY","type":13,"count":1},{"name":"dirZ","type":13,"count":1}],"defines":[]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]},{"name":"targetTex","type":29,"count":1,"binding":31,"defines":["USE_TARGET"]}]}],[{"passes":[{"program":"火2|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"targetTex":{"value":"white","type":29},"alphaThreshold":{"type":13,"value":[0.5]},"selfXYWH":{"type":16,"value":[0,0,1,1]},"selfRect":{"type":16,"value":[0,0,256,256]},"spSlice":{"type":16,"value":[0,0,1,1]},"selfSlice":{"type":16,"value":[0,0,1,1]},"targetXYWH":{"type":16,"value":[0,0,1,1]},"targetRect":{"type":16,"value":[0,0,256,256]},"ran":{"type":13,"value":[0],"editor":{"tooltip":"随机数 [0, 1)","range":[0,1]}},"color1":{"type":16,"value":[1,0.5,0.1,1],"editor":{"type":"color","tooltip":"火焰颜色1"}},"color2":{"type":16,"value":[0.1,0.5,1,1],"editor":{"type":"color","tooltip":"火焰颜色2"}},"dirX":{"type":13,"value":[1.5],"editor":{"tooltip":"方向X","range":[-10,100]}},"dirY":{"type":13,"value":[1],"editor":{"tooltip":"方向Y","range":[-10,100]}},"dirZ":{"type":13,"value":[-1.5],"editor":{"tooltip":"方向Z","range":[-10,10]}}}}]}]]],0,0,[],[],[]]]]