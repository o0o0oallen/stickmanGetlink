[1,["c4x+rsj/hP8bCZJ0jQB9Tu"],["_effectAsset"],[["cc.Material",["_name","_techniqueData"],1],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,3],[1,0,1,2,4]],[[[[0,"火",{"0":{"defines":{"USE_TEXTURE":true}}}]],0,0,[0],[0],[0]],[[[1,"火",[{"hash":1747362743,"record":null,"name":"火|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\n  in vec4 v_color;\n  #if USE_TEXTURE\n  in vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\n  #if USE_TARGET\n  uniform sampler2D targetTex;\n  #endif\n  uniform ubo {\n    vec4 targetXYWH;\n    vec4 targetRect;\n    vec4 selfXYWH;\n    vec4 selfRect;\n    vec4 spSlice;\n    vec4 selfSlice;\n    vec4 circleColor;\n    vec4 flame1Color;\n    vec4 flame2Color;\n    vec4 flame3Color;\n    float ran;\n    float circleR;\n    float circleJumpSpeed;\n    float flameSize;\n    float flame1Threshold;\n    float flame1Smooth;\n    float flame2Threshold;\n    float flame2Smooth;\n    float flame3Threshold;\n    float flame3Smooth;\n  };\n  vec4 getColor(vec2 uv0) {\n    vec4 o = vec4(1, 1, 1, 1);\n    #if USE_TARGET\n  vec4 targetTex_tmp = texture(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw);\n  #if CC_USE_ALPHA_ATLAS_targetTex\n      targetTex_tmp.a *= texture(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (targetTex_tmp.rgb * targetTex_tmp.rgb);\n    o.a *= targetTex_tmp.a;\n  #else\n    o *= targetTex_tmp;\n  #endif\n    #elif USE_TEXTURE\n  vec4 texture_tmp = texture(texture, uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture(texture, uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n    #endif\n    return o;\n  }\n  vec2 gnoise_random(vec2 uv){\n    uv = vec2(dot(uv, vec2(127.1, 311.7)), dot(uv, vec2(269.5,183.3)));\n    return fract(sin(uv) * 43758.5453123) * 2.0 - 1.0;\n  }\n  float gnoise(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    vec2 a = gnoise_random(i);\n    vec2 v1 = f;\n    vec2 b = gnoise_random(i + vec2(1.0, 0.0));\n    vec2 v2 = f - vec2(1.0, 0.0);\n    vec2 c = gnoise_random(i + vec2(0.0, 1.0));\n    vec2 v3 = f - vec2(0.0, 1.0);\n    vec2 d = gnoise_random(i + vec2(1.0, 1.0));\n    vec2 v4 = f - vec2(1.0, 1.0);\n    f *= f * (3.0 - 2.0 * f);\n    return mix(mix(dot(a, v1), dot(b, v2), f.x), mix(dot(c, v3), dot(d, v4), f.x), f.y);\n  }\n  void main () {\n    vec4 o = getColor(v_uv0);\n    vec2 realUV0 = (v_uv0 - selfXYWH.xy) / selfXYWH.zw;\n    vec2 realUV = realUV0;\n#if USE_SLICE\n    realUV = ((realUV - 0.0) / (spSlice.xy - 0.0) * (selfSlice.xy - 0.0) + 0.0) * step(realUV, spSlice.xy)\n      + ((realUV - spSlice.xy) / (spSlice.zw - spSlice.xy) * (selfSlice.zw - selfSlice.xy) + selfSlice.xy) * (step(spSlice.xy, realUV) - step(spSlice.zw, realUV))\n      + ((realUV - spSlice.zw) / (1.0 - spSlice.zw) * (1.0 - selfSlice.zw) + selfSlice.zw) * step(spSlice.zw, realUV.xy)\n    ;\n#endif\n    vec2 v = realUV - vec2(0.5, 0.5);\n    v.y /= selfRect.z / selfRect.w;\n    v /= circleR;\n    float dd = dot(v, v);\n    dd = max(1.0 - dd * 4.0, 0.0);\n    float fireSize = gnoise(vec2(cc_time.x * circleJumpSpeed, 0.0));\n    dd += fireSize * 0.2;\n    vec4 _o = circleColor * dd;\n    vec2 mn = vec2(20.0, 20.0 * selfRect.w / selfRect.z);\n    vec2 uv = realUV;\n    uv += vec2(-cc_time.x * 0.1, cc_time.x * 0.2);\n    uv *= mn;\n    float axisNoise = gnoise(uv);\n    axisNoise = (1.0 + axisNoise) * 0.5;\n    float flameJump = gnoise(vec2(cc_time.x * 1.0, 0.0));\n    flameJump = (1.0 + flameJump) * 0.5;\n    mn = vec2(1, selfRect.w / selfRect.z) * 100.0 / flameSize;\n    mn *= 1.0 + flameJump * 0.2;\n    uv = realUV;\n    uv -= 0.5;\n    uv += vec2(axisNoise * 0.1, axisNoise * 0.1);\n    uv *= mn;\n    float shapeNoise = gnoise(uv);\n    shapeNoise = (1.0 + shapeNoise) * 0.5;\n    _o += flame1Color * smoothstep(flame1Threshold, flame1Threshold + flame1Smooth, shapeNoise);\n    _o += flame2Color * smoothstep(flame2Threshold, flame2Threshold + flame2Smooth, shapeNoise);\n    _o += flame3Color * smoothstep(flame3Threshold, flame3Threshold + flame3Smooth, shapeNoise);\n    #if SHOW_TARGET\n      o.xyz += _o.xyz * _o.w;\n    #else\n      o.xyz = _o.xyz;\n      o.a *= _o.w;\n    #endif\n    o *= v_color;\n    ALPHA_TEST(o);\n    gl_FragColor = o;\n  }"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform vec4 cc_time;\n  varying vec4 v_color;\n  #if USE_TEXTURE\n  varying vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\n  #if USE_TARGET\n  uniform sampler2D targetTex;\n  #endif\n  uniform vec4 targetXYWH;\nuniform vec4 targetRect;\nuniform vec4 selfXYWH;\nuniform vec4 selfRect;\nuniform vec4 spSlice;\nuniform vec4 selfSlice;\nuniform vec4 circleColor;\nuniform vec4 flame1Color;\nuniform vec4 flame2Color;\nuniform vec4 flame3Color;\nuniform float circleR;\nuniform float circleJumpSpeed;\nuniform float flameSize;\nuniform float flame1Threshold;\nuniform float flame1Smooth;\nuniform float flame2Threshold;\nuniform float flame2Smooth;\nuniform float flame3Threshold;\nuniform float flame3Smooth;\n  vec4 getColor(vec2 uv0) {\n    vec4 o = vec4(1, 1, 1, 1);\n    #if USE_TARGET\n  vec4 targetTex_tmp = texture2D(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw);\n  #if CC_USE_ALPHA_ATLAS_targetTex\n      targetTex_tmp.a *= texture2D(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (targetTex_tmp.rgb * targetTex_tmp.rgb);\n    o.a *= targetTex_tmp.a;\n  #else\n    o *= targetTex_tmp;\n  #endif\n    #elif USE_TEXTURE\n  vec4 texture_tmp = texture2D(texture, uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture2D(texture, uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n    #endif\n    return o;\n  }\n  vec2 gnoise_random(vec2 uv){\n    uv = vec2(dot(uv, vec2(127.1, 311.7)), dot(uv, vec2(269.5,183.3)));\n    return fract(sin(uv) * 43758.5453123) * 2.0 - 1.0;\n  }\n  float gnoise(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    vec2 a = gnoise_random(i);\n    vec2 v1 = f;\n    vec2 b = gnoise_random(i + vec2(1.0, 0.0));\n    vec2 v2 = f - vec2(1.0, 0.0);\n    vec2 c = gnoise_random(i + vec2(0.0, 1.0));\n    vec2 v3 = f - vec2(0.0, 1.0);\n    vec2 d = gnoise_random(i + vec2(1.0, 1.0));\n    vec2 v4 = f - vec2(1.0, 1.0);\n    f *= f * (3.0 - 2.0 * f);\n    return mix(mix(dot(a, v1), dot(b, v2), f.x), mix(dot(c, v3), dot(d, v4), f.x), f.y);\n  }\n  void main () {\n    vec4 o = getColor(v_uv0);\n    vec2 realUV0 = (v_uv0 - selfXYWH.xy) / selfXYWH.zw;\n    vec2 realUV = realUV0;\n#if USE_SLICE\n    realUV = ((realUV - 0.0) / (spSlice.xy - 0.0) * (selfSlice.xy - 0.0) + 0.0) * step(realUV, spSlice.xy)\n      + ((realUV - spSlice.xy) / (spSlice.zw - spSlice.xy) * (selfSlice.zw - selfSlice.xy) + selfSlice.xy) * (step(spSlice.xy, realUV) - step(spSlice.zw, realUV))\n      + ((realUV - spSlice.zw) / (1.0 - spSlice.zw) * (1.0 - selfSlice.zw) + selfSlice.zw) * step(spSlice.zw, realUV.xy)\n    ;\n#endif\n    vec2 v = realUV - vec2(0.5, 0.5);\n    v.y /= selfRect.z / selfRect.w;\n    v /= circleR;\n    float dd = dot(v, v);\n    dd = max(1.0 - dd * 4.0, 0.0);\n    float fireSize = gnoise(vec2(cc_time.x * circleJumpSpeed, 0.0));\n    dd += fireSize * 0.2;\n    vec4 _o = circleColor * dd;\n    vec2 mn = vec2(20.0, 20.0 * selfRect.w / selfRect.z);\n    vec2 uv = realUV;\n    uv += vec2(-cc_time.x * 0.1, cc_time.x * 0.2);\n    uv *= mn;\n    float axisNoise = gnoise(uv);\n    axisNoise = (1.0 + axisNoise) * 0.5;\n    float flameJump = gnoise(vec2(cc_time.x * 1.0, 0.0));\n    flameJump = (1.0 + flameJump) * 0.5;\n    mn = vec2(1, selfRect.w / selfRect.z) * 100.0 / flameSize;\n    mn *= 1.0 + flameJump * 0.2;\n    uv = realUV;\n    uv -= 0.5;\n    uv += vec2(axisNoise * 0.1, axisNoise * 0.1);\n    uv *= mn;\n    float shapeNoise = gnoise(uv);\n    shapeNoise = (1.0 + shapeNoise) * 0.5;\n    _o += flame1Color * smoothstep(flame1Threshold, flame1Threshold + flame1Smooth, shapeNoise);\n    _o += flame2Color * smoothstep(flame2Threshold, flame2Threshold + flame2Smooth, shapeNoise);\n    _o += flame3Color * smoothstep(flame3Threshold, flame3Threshold + flame3Smooth, shapeNoise);\n    #if SHOW_TARGET\n      o.xyz += _o.xyz * _o.w;\n    #else\n      o.xyz = _o.xyz;\n      o.a *= _o.w;\n    #endif\n    o *= v_color;\n    ALPHA_TEST(o);\n    gl_FragColor = o;\n  }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"USE_TARGET","type":"boolean","defines":[]},{"name":"CC_USE_ALPHA_ATLAS_targetTex","type":"boolean","defines":["USE_TARGET"]},{"name":"INPUT_IS_GAMMA","type":"boolean","defines":["USE_TARGET"]},{"name":"CC_USE_ALPHA_ATLAS_texture","type":"boolean","defines":["USE_TEXTURE"]},{"name":"USE_SLICE","type":"boolean","defines":[]},{"name":"SHOW_TARGET","type":"boolean","defines":[]}],"blocks":[{"name":"ALPHA_TEST","binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"ubo","binding":1,"members":[{"name":"targetXYWH","type":16,"count":1},{"name":"targetRect","type":16,"count":1},{"name":"selfXYWH","type":16,"count":1},{"name":"selfRect","type":16,"count":1},{"name":"spSlice","type":16,"count":1},{"name":"selfSlice","type":16,"count":1},{"name":"circleColor","type":16,"count":1},{"name":"flame1Color","type":16,"count":1},{"name":"flame2Color","type":16,"count":1},{"name":"flame3Color","type":16,"count":1},{"name":"ran","type":13,"count":1},{"name":"circleR","type":13,"count":1},{"name":"circleJumpSpeed","type":13,"count":1},{"name":"flameSize","type":13,"count":1},{"name":"flame1Threshold","type":13,"count":1},{"name":"flame1Smooth","type":13,"count":1},{"name":"flame2Threshold","type":13,"count":1},{"name":"flame2Smooth","type":13,"count":1},{"name":"flame3Threshold","type":13,"count":1},{"name":"flame3Smooth","type":13,"count":1}],"defines":[]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]},{"name":"targetTex","type":29,"count":1,"binding":31,"defines":["USE_TARGET"]}]}],[{"passes":[{"program":"火|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"targetTex":{"value":"white","type":29},"alphaThreshold":{"type":13,"value":[0.5]},"selfXYWH":{"type":16,"value":[0,0,1,1]},"selfRect":{"type":16,"value":[0,0,256,256]},"spSlice":{"type":16,"value":[0,0,1,1]},"selfSlice":{"type":16,"value":[0,0,1,1]},"targetXYWH":{"type":16,"value":[0,0,1,1]},"targetRect":{"type":16,"value":[0,0,256,256]},"ran":{"type":13,"value":[0],"editor":{"tooltip":"随机数 [0, 1)","range":[0,1]}},"circleColor":{"type":16,"value":[1,1,0,1],"editor":{"type":"color","tooltip":"底圆颜色"}},"circleR":{"type":13,"value":[0.5],"editor":{"tooltip":"底圆半径","range":[0,1]}},"circleJumpSpeed":{"type":13,"value":[10],"editor":{"tooltip":"底圆跳动快慢","range":[0,100]}},"flame1Color":{"type":16,"value":[1,0.2,0,1],"editor":{"type":"color","tooltip":"外焰"}},"flame2Color":{"type":16,"value":[1,0.9,0,1],"editor":{"type":"color","tooltip":"中焰"}},"flame3Color":{"type":16,"value":[1,1,1,1],"editor":{"type":"color","tooltip":"内焰"}},"flameSize":{"type":13,"value":[8],"editor":{"tooltip":"火焰大小","range":[0,100]}},"flame1Threshold":{"type":13,"value":[0.3],"editor":{"tooltip":"外焰alpha阈值","range":[0,1]}},"flame1Smooth":{"type":13,"value":[0.1],"editor":{"tooltip":"外焰过渡区厚度","range":[0,1]}},"flame2Threshold":{"type":13,"value":[0.4],"editor":{"tooltip":"中焰alpha阈值","range":[0,1]}},"flame2Smooth":{"type":13,"value":[0.1],"editor":{"tooltip":"中焰过渡区厚度","range":[0,1]}},"flame3Threshold":{"type":13,"value":[0.5],"editor":{"tooltip":"内焰alpha阈值","range":[0,1]}},"flame3Smooth":{"type":13,"value":[0.1],"editor":{"tooltip":"内焰过渡区厚度","range":[0,1]}}}}]}]]],0,0,[],[],[]]]]