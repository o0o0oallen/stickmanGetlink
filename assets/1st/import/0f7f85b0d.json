[1,["f49+XI7AlM3JrxNXSjieUe"],["_effectAsset"],[["cc.Material",["_name","_techniqueData"],1],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,3],[1,0,1,2,4]],[[[[0,"进度",{"0":{"defines":{"USE_TEXTURE":true}}}]],0,0,[0],[0],[0]],[[[1,"进度",[{"hash":246862704,"record":null,"name":"进度|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\n  in vec4 v_color;\n  #if USE_TEXTURE\n  in vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\n  #if USE_TARGET\n  uniform sampler2D targetTex;\n  #endif\n  uniform ubo {\n    vec4 targetXYWH;\n    vec4 targetRect;\n    vec4 selfXYWH;\n    vec4 selfRect;\n    vec4 spSlice;\n    vec4 selfSlice;\n    vec4 color;\n    float ran;\n    float progress;\n    float lightSize;\n    float lightSpeed;\n    float gridSize;\n    float outlineThickness;\n    float outlineStrength;\n    float flameSize;\n    float flameSpeed;\n  };\n  vec4 getColor(vec2 uv0) {\n    vec4 o = vec4(1, 1, 1, 1);\n    #if USE_TARGET\n  vec4 targetTex_tmp = texture(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw);\n  #if CC_USE_ALPHA_ATLAS_targetTex\n      targetTex_tmp.a *= texture(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (targetTex_tmp.rgb * targetTex_tmp.rgb);\n    o.a *= targetTex_tmp.a;\n  #else\n    o *= targetTex_tmp;\n  #endif\n    #elif USE_TEXTURE\n  vec4 texture_tmp = texture(texture, uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture(texture, uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n    #endif\n    return o;\n  }\n  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n  float snoise(vec2 v) {\n      const vec4 C = vec4(0.211324865405187,\n                          0.366025403784439,\n                          -0.577350269189626,\n                          0.024390243902439);\n      vec2 i  = floor(v + dot(v, C.yy));\n      vec2 x0 = v - i + dot(i, C.xx);\n      vec2 i1 = vec2(0.0);\n      i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n      vec2 x1 = x0.xy + C.xx - i1;\n      vec2 x2 = x0.xy + C.zz;\n      i = mod289(i);\n      vec3 p = permute(\n              permute( i.y + vec3(0.0, i1.y, 1.0))\n                  + i.x + vec3(0.0, i1.x, 1.0 ));\n      vec3 m = max(0.5 - vec3(\n                          dot(x0,x0),\n                          dot(x1,x1),\n                          dot(x2,x2)\n                          ), 0.0);\n      m = m*m ;\n      m = m*m ;\n      vec3 x = 2.0 * fract(p * C.www) - 1.0;\n      vec3 h = abs(x) - 0.5;\n      vec3 ox = floor(x + 0.5);\n      vec3 a0 = x - ox;\n      m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n      vec3 g = vec3(0.0);\n      g.x  = a0.x  * x0.x  + h.x  * x0.y;\n      g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n      return 130.0 * dot(m, g);\n  }\n  float getAlpha(vec2 realUV0) {\n    #if HORIZONTAL\n      return getColor(realUV0 * selfXYWH.zw + selfXYWH.xy).w * step(realUV0.x, progress);\n    #else\n      return getColor(realUV0 * selfXYWH.zw + selfXYWH.xy).w * step(1.0 - progress, realUV0.y);\n    #endif\n  }\n  void main () {\n    vec4 o = getColor(v_uv0);\n    vec2 realUV0 = (v_uv0 - selfXYWH.xy) / selfXYWH.zw;\n    vec2 realUV = realUV0;\n#if USE_SLICE\n    realUV = ((realUV - 0.0) / (spSlice.xy - 0.0) * (selfSlice.xy - 0.0) + 0.0) * step(realUV, spSlice.xy)\n      + ((realUV - spSlice.xy) / (spSlice.zw - spSlice.xy) * (selfSlice.zw - selfSlice.xy) + selfSlice.xy) * (step(spSlice.xy, realUV) - step(spSlice.zw, realUV))\n      + ((realUV - spSlice.zw) / (1.0 - spSlice.zw) * (1.0 - selfSlice.zw) + selfSlice.zw) * step(spSlice.zw, realUV.xy)\n    ;\n#endif\n    float a = getAlpha(realUV0);\n    float value = 0.0;\n    #if HORIZONTAL\n      float _lightSize = lightSize / selfRect.z;\n      float lightPos = fract(cc_time.x / (selfRect.z / lightSpeed)) * (1.0 + _lightSize);\n      float light = smoothstep(lightPos - _lightSize, lightPos, realUV0.x) - step(lightPos, realUV0.x);\n    #else\n      float _lightSize = lightSize / selfRect.w;\n      float lightPos = 1.0 - fract(cc_time.x / (selfRect.w / lightSpeed)) * (1.0 + _lightSize);\n      float light = smoothstep(lightPos + _lightSize, lightPos, realUV0.y) - step(realUV0.y, lightPos);\n    #endif\n    light *= a;\n    value = mix(value, 1.0, light * 0.6);\n    vec2 mn = selfRect.zw / gridSize;\n    vec2 lineWH = 2.0 / selfRect.zw;\n    lineWH *= mn;\n    vec2 uv = fract(realUV0 * mn);\n    vec2 grid = smoothstep(vec2(0.0), lineWH * 0.1, uv) - smoothstep(lineWH * 0.1, lineWH, uv);\n    float gridLine = (grid.x + grid.y) * light;\n    value = mix(value, 1.0, gridLine);\n    float ava = 0.0;\n    const float d2 = 1.0;\n    for (float dy = -d2; dy <= d2; dy++){\n      for (float dx = -d2; dx <= d2; dx++){\n        ava += getAlpha(realUV0 + vec2(dx, dy) * outlineThickness / selfRect.zw);\n      }\n    }\n    ava /= (d2 * 2.0 + 1.0) * (d2 * 2.0 + 1.0);\n    float outline = smoothstep(0.0, 0.5 / outlineStrength, ava) - smoothstep(1.0 - 0.5 / outlineStrength, 1.0, ava);\n    value = mix(value, 1.0, outline);\n    #if HORIZONTAL\n      float _flameSize = flameSize / selfRect.z;\n    #else\n      float _flameSize = flameSize / selfRect.w;\n    #endif\n    mn = selfRect.zw / (flameSize / 4.0);\n    uv = realUV0;\n    #if HORIZONTAL\n      uv.x -= cc_time.x / (selfRect.z / flameSpeed);\n    #else\n      uv.y += cc_time.x / (selfRect.w / flameSpeed);\n    #endif\n    uv *= mn;\n    float noise = snoise(uv);\n    noise = (1.0 + noise) * 0.5;\n    #if HORIZONTAL\n      float flameAlpha = smoothstep(progress + _flameSize, progress, realUV0.x) * step(progress, realUV0.x);\n    #else\n      float flameAlpha = smoothstep((1.0 - progress) - _flameSize, (1.0 - progress), realUV0.y) * step(realUV0.y, 1.0 - progress);\n    #endif\n    noise *= flameAlpha;\n    value = mix(value, 1.0, noise);\n    vec4 _o = vec4(color.xyz, color.w * value);\n    #if SHOW_TARGET\n      o.xyz += _o.xyz * _o.w;\n    #else\n      o.xyz = _o.xyz;\n      o.a *= _o.w;\n    #endif\n    o *= v_color;\n    ALPHA_TEST(o);\n    gl_FragColor = o;\n  }"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform vec4 cc_time;\n  varying vec4 v_color;\n  #if USE_TEXTURE\n  varying vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\n  #if USE_TARGET\n  uniform sampler2D targetTex;\n  #endif\n  uniform vec4 targetXYWH;\nuniform vec4 targetRect;\nuniform vec4 selfXYWH;\nuniform vec4 selfRect;\nuniform vec4 spSlice;\nuniform vec4 selfSlice;\nuniform vec4 color;\nuniform float progress;\nuniform float lightSize;\nuniform float lightSpeed;\nuniform float gridSize;\nuniform float outlineThickness;\nuniform float outlineStrength;\nuniform float flameSize;\nuniform float flameSpeed;\n  vec4 getColor(vec2 uv0) {\n    vec4 o = vec4(1, 1, 1, 1);\n    #if USE_TARGET\n  vec4 targetTex_tmp = texture2D(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw);\n  #if CC_USE_ALPHA_ATLAS_targetTex\n      targetTex_tmp.a *= texture2D(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (targetTex_tmp.rgb * targetTex_tmp.rgb);\n    o.a *= targetTex_tmp.a;\n  #else\n    o *= targetTex_tmp;\n  #endif\n    #elif USE_TEXTURE\n  vec4 texture_tmp = texture2D(texture, uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture2D(texture, uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n    #endif\n    return o;\n  }\n  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n  float snoise(vec2 v) {\n      const vec4 C = vec4(0.211324865405187,\n                          0.366025403784439,\n                          -0.577350269189626,\n                          0.024390243902439);\n      vec2 i  = floor(v + dot(v, C.yy));\n      vec2 x0 = v - i + dot(i, C.xx);\n      vec2 i1 = vec2(0.0);\n      i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n      vec2 x1 = x0.xy + C.xx - i1;\n      vec2 x2 = x0.xy + C.zz;\n      i = mod289(i);\n      vec3 p = permute(\n              permute( i.y + vec3(0.0, i1.y, 1.0))\n                  + i.x + vec3(0.0, i1.x, 1.0 ));\n      vec3 m = max(0.5 - vec3(\n                          dot(x0,x0),\n                          dot(x1,x1),\n                          dot(x2,x2)\n                          ), 0.0);\n      m = m*m ;\n      m = m*m ;\n      vec3 x = 2.0 * fract(p * C.www) - 1.0;\n      vec3 h = abs(x) - 0.5;\n      vec3 ox = floor(x + 0.5);\n      vec3 a0 = x - ox;\n      m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n      vec3 g = vec3(0.0);\n      g.x  = a0.x  * x0.x  + h.x  * x0.y;\n      g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n      return 130.0 * dot(m, g);\n  }\n  float getAlpha(vec2 realUV0) {\n    #if HORIZONTAL\n      return getColor(realUV0 * selfXYWH.zw + selfXYWH.xy).w * step(realUV0.x, progress);\n    #else\n      return getColor(realUV0 * selfXYWH.zw + selfXYWH.xy).w * step(1.0 - progress, realUV0.y);\n    #endif\n  }\n  void main () {\n    vec4 o = getColor(v_uv0);\n    vec2 realUV0 = (v_uv0 - selfXYWH.xy) / selfXYWH.zw;\n    vec2 realUV = realUV0;\n#if USE_SLICE\n    realUV = ((realUV - 0.0) / (spSlice.xy - 0.0) * (selfSlice.xy - 0.0) + 0.0) * step(realUV, spSlice.xy)\n      + ((realUV - spSlice.xy) / (spSlice.zw - spSlice.xy) * (selfSlice.zw - selfSlice.xy) + selfSlice.xy) * (step(spSlice.xy, realUV) - step(spSlice.zw, realUV))\n      + ((realUV - spSlice.zw) / (1.0 - spSlice.zw) * (1.0 - selfSlice.zw) + selfSlice.zw) * step(spSlice.zw, realUV.xy)\n    ;\n#endif\n    float a = getAlpha(realUV0);\n    float value = 0.0;\n    #if HORIZONTAL\n      float _lightSize = lightSize / selfRect.z;\n      float lightPos = fract(cc_time.x / (selfRect.z / lightSpeed)) * (1.0 + _lightSize);\n      float light = smoothstep(lightPos - _lightSize, lightPos, realUV0.x) - step(lightPos, realUV0.x);\n    #else\n      float _lightSize = lightSize / selfRect.w;\n      float lightPos = 1.0 - fract(cc_time.x / (selfRect.w / lightSpeed)) * (1.0 + _lightSize);\n      float light = smoothstep(lightPos + _lightSize, lightPos, realUV0.y) - step(realUV0.y, lightPos);\n    #endif\n    light *= a;\n    value = mix(value, 1.0, light * 0.6);\n    vec2 mn = selfRect.zw / gridSize;\n    vec2 lineWH = 2.0 / selfRect.zw;\n    lineWH *= mn;\n    vec2 uv = fract(realUV0 * mn);\n    vec2 grid = smoothstep(vec2(0.0), lineWH * 0.1, uv) - smoothstep(lineWH * 0.1, lineWH, uv);\n    float gridLine = (grid.x + grid.y) * light;\n    value = mix(value, 1.0, gridLine);\n    float ava = 0.0;\n    const float d2 = 1.0;\n    for (float dy = -d2; dy <= d2; dy++){\n      for (float dx = -d2; dx <= d2; dx++){\n        ava += getAlpha(realUV0 + vec2(dx, dy) * outlineThickness / selfRect.zw);\n      }\n    }\n    ava /= (d2 * 2.0 + 1.0) * (d2 * 2.0 + 1.0);\n    float outline = smoothstep(0.0, 0.5 / outlineStrength, ava) - smoothstep(1.0 - 0.5 / outlineStrength, 1.0, ava);\n    value = mix(value, 1.0, outline);\n    #if HORIZONTAL\n      float _flameSize = flameSize / selfRect.z;\n    #else\n      float _flameSize = flameSize / selfRect.w;\n    #endif\n    mn = selfRect.zw / (flameSize / 4.0);\n    uv = realUV0;\n    #if HORIZONTAL\n      uv.x -= cc_time.x / (selfRect.z / flameSpeed);\n    #else\n      uv.y += cc_time.x / (selfRect.w / flameSpeed);\n    #endif\n    uv *= mn;\n    float noise = snoise(uv);\n    noise = (1.0 + noise) * 0.5;\n    #if HORIZONTAL\n      float flameAlpha = smoothstep(progress + _flameSize, progress, realUV0.x) * step(progress, realUV0.x);\n    #else\n      float flameAlpha = smoothstep((1.0 - progress) - _flameSize, (1.0 - progress), realUV0.y) * step(realUV0.y, 1.0 - progress);\n    #endif\n    noise *= flameAlpha;\n    value = mix(value, 1.0, noise);\n    vec4 _o = vec4(color.xyz, color.w * value);\n    #if SHOW_TARGET\n      o.xyz += _o.xyz * _o.w;\n    #else\n      o.xyz = _o.xyz;\n      o.a *= _o.w;\n    #endif\n    o *= v_color;\n    ALPHA_TEST(o);\n    gl_FragColor = o;\n  }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"USE_TARGET","type":"boolean","defines":[]},{"name":"CC_USE_ALPHA_ATLAS_targetTex","type":"boolean","defines":["USE_TARGET"]},{"name":"INPUT_IS_GAMMA","type":"boolean","defines":["USE_TARGET"]},{"name":"CC_USE_ALPHA_ATLAS_texture","type":"boolean","defines":["USE_TEXTURE"]},{"name":"HORIZONTAL","type":"boolean","defines":[]},{"name":"USE_SLICE","type":"boolean","defines":[]},{"name":"SHOW_TARGET","type":"boolean","defines":[]}],"blocks":[{"name":"ALPHA_TEST","binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"ubo","binding":1,"members":[{"name":"targetXYWH","type":16,"count":1},{"name":"targetRect","type":16,"count":1},{"name":"selfXYWH","type":16,"count":1},{"name":"selfRect","type":16,"count":1},{"name":"spSlice","type":16,"count":1},{"name":"selfSlice","type":16,"count":1},{"name":"color","type":16,"count":1},{"name":"ran","type":13,"count":1},{"name":"progress","type":13,"count":1},{"name":"lightSize","type":13,"count":1},{"name":"lightSpeed","type":13,"count":1},{"name":"gridSize","type":13,"count":1},{"name":"outlineThickness","type":13,"count":1},{"name":"outlineStrength","type":13,"count":1},{"name":"flameSize","type":13,"count":1},{"name":"flameSpeed","type":13,"count":1}],"defines":[]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]},{"name":"targetTex","type":29,"count":1,"binding":31,"defines":["USE_TARGET"]}]}],[{"passes":[{"program":"进度|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"targetTex":{"value":"white","type":29},"alphaThreshold":{"type":13,"value":[0.5]},"selfXYWH":{"type":16,"value":[0,0,1,1]},"selfRect":{"type":16,"value":[0,0,256,256]},"spSlice":{"type":16,"value":[0,0,1,1]},"selfSlice":{"type":16,"value":[0,0,1,1]},"targetXYWH":{"type":16,"value":[0,0,1,1]},"targetRect":{"type":16,"value":[0,0,256,256]},"ran":{"type":13,"value":[0],"editor":{"tooltip":"随机数 [0, 1)","range":[0,1]}},"color":{"type":16,"value":[0,1,0.2,1],"editor":{"type":"color"}},"progress":{"type":13,"value":[0.7],"editor":{"tooltip":"进度","range":[0,1]}},"lightSize":{"type":13,"value":[100],"editor":{"tooltip":"扫光大小（像素）","range":[0,1000]}},"lightSpeed":{"type":13,"value":[50],"editor":{"tooltip":"扫光速度（像素/秒）","range":[0,1000]}},"gridSize":{"type":13,"value":[6],"editor":{"tooltip":"格子大小（像素）","range":[0,100]}},"outlineThickness":{"type":13,"value":[2],"editor":{"tooltip":"描边厚度","range":[0,10]}},"outlineStrength":{"type":13,"value":[2],"editor":{"tooltip":"描边强度","range":[1,10]}},"flameSize":{"type":13,"value":[50],"editor":{"tooltip":"尾焰大小（像素）","range":[1,1000]}},"flameSpeed":{"type":13,"value":[20],"editor":{"tooltip":"尾焰速度（像素）","range":[1,300]}}}}]}]]],0,0,[],[],[]]]]