[1,["e3/5HLWpdK0qf5wZsh9WO+"],["_effectAsset"],[["cc.Material",["_name","_techniqueData"],1],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,3],[1,0,1,2,4]],[[[[0,"闪电",{"0":{"defines":{"USE_TEXTURE":true}}}]],0,0,[0],[0],[0]],[[[1,"闪电",[{"hash":3290349529,"record":null,"name":"闪电|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\n  in vec4 v_color;\n  #if USE_TEXTURE\n  in vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\n  #if USE_TARGET\n  uniform sampler2D targetTex;\n  #endif\n  uniform ubo {\n    vec4 targetXYWH;\n    vec4 targetRect;\n    vec4 selfXYWH;\n    vec4 selfRect;\n    vec4 spSlice;\n    vec4 selfSlice;\n    vec4 color;\n    vec4 centerColor;\n    float ran;\n    float seg;\n    float thickness;\n    float rough;\n    float speed;\n  };\n  vec4 getColor(vec2 uv0) {\n    vec4 o = vec4(1, 1, 1, 1);\n    #if USE_TARGET\n  vec4 targetTex_tmp = texture(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw);\n  #if CC_USE_ALPHA_ATLAS_targetTex\n      targetTex_tmp.a *= texture(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (targetTex_tmp.rgb * targetTex_tmp.rgb);\n    o.a *= targetTex_tmp.a;\n  #else\n    o *= targetTex_tmp;\n  #endif\n    #elif USE_TEXTURE\n  vec4 texture_tmp = texture(texture, uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture(texture, uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n    #endif\n    return o;\n  }\n  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n  float snoise(vec2 v) {\n      const vec4 C = vec4(0.211324865405187,\n                          0.366025403784439,\n                          -0.577350269189626,\n                          0.024390243902439);\n      vec2 i  = floor(v + dot(v, C.yy));\n      vec2 x0 = v - i + dot(i, C.xx);\n      vec2 i1 = vec2(0.0);\n      i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n      vec2 x1 = x0.xy + C.xx - i1;\n      vec2 x2 = x0.xy + C.zz;\n      i = mod289(i);\n      vec3 p = permute(\n              permute( i.y + vec3(0.0, i1.y, 1.0))\n                  + i.x + vec3(0.0, i1.x, 1.0 ));\n      vec3 m = max(0.5 - vec3(\n                          dot(x0,x0),\n                          dot(x1,x1),\n                          dot(x2,x2)\n                          ), 0.0);\n      m = m*m ;\n      m = m*m ;\n      vec3 x = 2.0 * fract(p * C.www) - 1.0;\n      vec3 h = abs(x) - 0.5;\n      vec3 ox = floor(x + 0.5);\n      vec3 a0 = x - ox;\n      m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n      vec3 g = vec3(0.0);\n      g.x  = a0.x  * x0.x  + h.x  * x0.y;\n      g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n      return 130.0 * dot(m, g);\n  }\n  float fbm (vec2 uv) {\n    return 0.5 * snoise(uv)\n      + 0.25 * snoise(uv * 2.0)\n      + 0.125 * snoise(uv * 4.0)\n      + 0.0625 * snoise(uv * 8.0)\n    ;\n  }\n  void main () {\n    vec4 o = getColor(v_uv0);\n    vec2 realUV0 = (v_uv0 - selfXYWH.xy) / selfXYWH.zw;\n    vec2 realUV = realUV0;\n#if USE_SLICE\n    realUV = ((realUV - 0.0) / (spSlice.xy - 0.0) * (selfSlice.xy - 0.0) + 0.0) * step(realUV, spSlice.xy)\n      + ((realUV - spSlice.xy) / (spSlice.zw - spSlice.xy) * (selfSlice.zw - selfSlice.xy) + selfSlice.xy) * (step(spSlice.xy, realUV) - step(spSlice.zw, realUV))\n      + ((realUV - spSlice.zw) / (1.0 - spSlice.zw) * (1.0 - selfSlice.zw) + selfSlice.zw) * step(spSlice.zw, realUV.xy)\n    ;\n#endif\n    vec2 mn = selfRect.zw / seg;\n    float th2 = thickness / selfRect.w / 2.0;\n    vec2 uv = realUV;\n    uv *= mn;\n    float _ran = fbm(uv + cc_time.x * speed);\n    _ran *= rough / selfRect.w;\n    float y = realUV.y + _ran;\n    float value = smoothstep(0.5 - th2, 0.5, y) - smoothstep(0.5, 0.5 + th2, y);\n    vec4 _o = vec4(color.xyz, color.w * value);\n    _o.xyz = mix(_o.xyz, centerColor.xyz, centerColor.w * value * value);\n    #if SHOW_TARGET\n      o.xyz += _o.xyz * _o.w;\n    #else\n      o.xyz = _o.xyz;\n      o.a *= _o.w;\n    #endif\n    o *= v_color;\n    ALPHA_TEST(o);\n    gl_FragColor = o;\n  }"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform vec4 cc_time;\n  varying vec4 v_color;\n  #if USE_TEXTURE\n  varying vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\n  #if USE_TARGET\n  uniform sampler2D targetTex;\n  #endif\n  uniform vec4 targetXYWH;\nuniform vec4 targetRect;\nuniform vec4 selfXYWH;\nuniform vec4 selfRect;\nuniform vec4 spSlice;\nuniform vec4 selfSlice;\nuniform vec4 color;\nuniform vec4 centerColor;\nuniform float seg;\nuniform float thickness;\nuniform float rough;\nuniform float speed;\n  vec4 getColor(vec2 uv0) {\n    vec4 o = vec4(1, 1, 1, 1);\n    #if USE_TARGET\n  vec4 targetTex_tmp = texture2D(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw);\n  #if CC_USE_ALPHA_ATLAS_targetTex\n      targetTex_tmp.a *= texture2D(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (targetTex_tmp.rgb * targetTex_tmp.rgb);\n    o.a *= targetTex_tmp.a;\n  #else\n    o *= targetTex_tmp;\n  #endif\n    #elif USE_TEXTURE\n  vec4 texture_tmp = texture2D(texture, uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture2D(texture, uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n    #endif\n    return o;\n  }\n  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n  float snoise(vec2 v) {\n      const vec4 C = vec4(0.211324865405187,\n                          0.366025403784439,\n                          -0.577350269189626,\n                          0.024390243902439);\n      vec2 i  = floor(v + dot(v, C.yy));\n      vec2 x0 = v - i + dot(i, C.xx);\n      vec2 i1 = vec2(0.0);\n      i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n      vec2 x1 = x0.xy + C.xx - i1;\n      vec2 x2 = x0.xy + C.zz;\n      i = mod289(i);\n      vec3 p = permute(\n              permute( i.y + vec3(0.0, i1.y, 1.0))\n                  + i.x + vec3(0.0, i1.x, 1.0 ));\n      vec3 m = max(0.5 - vec3(\n                          dot(x0,x0),\n                          dot(x1,x1),\n                          dot(x2,x2)\n                          ), 0.0);\n      m = m*m ;\n      m = m*m ;\n      vec3 x = 2.0 * fract(p * C.www) - 1.0;\n      vec3 h = abs(x) - 0.5;\n      vec3 ox = floor(x + 0.5);\n      vec3 a0 = x - ox;\n      m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n      vec3 g = vec3(0.0);\n      g.x  = a0.x  * x0.x  + h.x  * x0.y;\n      g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n      return 130.0 * dot(m, g);\n  }\n  float fbm (vec2 uv) {\n    return 0.5 * snoise(uv)\n      + 0.25 * snoise(uv * 2.0)\n      + 0.125 * snoise(uv * 4.0)\n      + 0.0625 * snoise(uv * 8.0)\n    ;\n  }\n  void main () {\n    vec4 o = getColor(v_uv0);\n    vec2 realUV0 = (v_uv0 - selfXYWH.xy) / selfXYWH.zw;\n    vec2 realUV = realUV0;\n#if USE_SLICE\n    realUV = ((realUV - 0.0) / (spSlice.xy - 0.0) * (selfSlice.xy - 0.0) + 0.0) * step(realUV, spSlice.xy)\n      + ((realUV - spSlice.xy) / (spSlice.zw - spSlice.xy) * (selfSlice.zw - selfSlice.xy) + selfSlice.xy) * (step(spSlice.xy, realUV) - step(spSlice.zw, realUV))\n      + ((realUV - spSlice.zw) / (1.0 - spSlice.zw) * (1.0 - selfSlice.zw) + selfSlice.zw) * step(spSlice.zw, realUV.xy)\n    ;\n#endif\n    vec2 mn = selfRect.zw / seg;\n    float th2 = thickness / selfRect.w / 2.0;\n    vec2 uv = realUV;\n    uv *= mn;\n    float _ran = fbm(uv + cc_time.x * speed);\n    _ran *= rough / selfRect.w;\n    float y = realUV.y + _ran;\n    float value = smoothstep(0.5 - th2, 0.5, y) - smoothstep(0.5, 0.5 + th2, y);\n    vec4 _o = vec4(color.xyz, color.w * value);\n    _o.xyz = mix(_o.xyz, centerColor.xyz, centerColor.w * value * value);\n    #if SHOW_TARGET\n      o.xyz += _o.xyz * _o.w;\n    #else\n      o.xyz = _o.xyz;\n      o.a *= _o.w;\n    #endif\n    o *= v_color;\n    ALPHA_TEST(o);\n    gl_FragColor = o;\n  }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"USE_TARGET","type":"boolean","defines":[]},{"name":"CC_USE_ALPHA_ATLAS_targetTex","type":"boolean","defines":["USE_TARGET"]},{"name":"INPUT_IS_GAMMA","type":"boolean","defines":["USE_TARGET"]},{"name":"CC_USE_ALPHA_ATLAS_texture","type":"boolean","defines":["USE_TEXTURE"]},{"name":"USE_SLICE","type":"boolean","defines":[]},{"name":"SHOW_TARGET","type":"boolean","defines":[]}],"blocks":[{"name":"ALPHA_TEST","binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"ubo","binding":1,"members":[{"name":"targetXYWH","type":16,"count":1},{"name":"targetRect","type":16,"count":1},{"name":"selfXYWH","type":16,"count":1},{"name":"selfRect","type":16,"count":1},{"name":"spSlice","type":16,"count":1},{"name":"selfSlice","type":16,"count":1},{"name":"color","type":16,"count":1},{"name":"centerColor","type":16,"count":1},{"name":"ran","type":13,"count":1},{"name":"seg","type":13,"count":1},{"name":"thickness","type":13,"count":1},{"name":"rough","type":13,"count":1},{"name":"speed","type":13,"count":1}],"defines":[]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]},{"name":"targetTex","type":29,"count":1,"binding":31,"defines":["USE_TARGET"]}]}],[{"passes":[{"program":"闪电|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"targetTex":{"value":"white","type":29},"alphaThreshold":{"type":13,"value":[0.5]},"selfXYWH":{"type":16,"value":[0,0,1,1]},"selfRect":{"type":16,"value":[0,0,256,256]},"spSlice":{"type":16,"value":[0,0,1,1]},"selfSlice":{"type":16,"value":[0,0,1,1]},"targetXYWH":{"type":16,"value":[0,0,1,1]},"targetRect":{"type":16,"value":[0,0,256,256]},"ran":{"type":13,"value":[0],"editor":{"tooltip":"随机数 [0, 1)","range":[0,1]}},"color":{"type":16,"value":[0,0.2,1,1],"editor":{"type":"color"}},"centerColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"seg":{"type":13,"value":[50],"editor":{"tooltip":"闪电节点距离（像素）","range":[0,1000]}},"thickness":{"type":13,"value":[10],"editor":{"tooltip":"闪电粗细（像素）","range":[0,100]}},"rough":{"type":13,"value":[8],"editor":{"tooltip":"闪电曲折度（像素）","range":[0,100]}},"speed":{"type":13,"value":[2],"editor":{"tooltip":"闪电快慢","range":[0,10]}}}}]}]]],0,0,[],[],[]]]]