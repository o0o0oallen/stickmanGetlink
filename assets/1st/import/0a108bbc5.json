[1,["42v2SEHBtJ1YSFPUbEhV/R"],["_effectAsset"],[["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Material",["_name","_techniqueData"],1]],[[0,0,1,2,4],[1,0,1,3]],[[[[0,"BUFF",[{"hash":3761815884,"record":null,"name":"BUFF|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\n  in vec4 v_color;\n  #if USE_TEXTURE\n  in vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\n  #if USE_TARGET\n  uniform sampler2D targetTex;\n  #endif\n  uniform ubo {\n    vec4 targetXYWH;\n    vec4 targetRect;\n    vec4 selfXYWH;\n    vec4 selfRect;\n    vec4 spSlice;\n    vec4 selfSlice;\n    vec4 color1;\n    vec4 color2;\n    float ran;\n    float lineW;\n    float lineH;\n    float lineSpeed;\n    float a1;\n    float b1;\n    float a2;\n    float b2;\n  };\n  vec4 getColor(vec2 uv0) {\n    vec4 o = vec4(1, 1, 1, 1);\n    #if USE_TARGET\n  vec4 targetTex_tmp = texture(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw);\n  #if CC_USE_ALPHA_ATLAS_targetTex\n      targetTex_tmp.a *= texture(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (targetTex_tmp.rgb * targetTex_tmp.rgb);\n    o.a *= targetTex_tmp.a;\n  #else\n    o *= targetTex_tmp;\n  #endif\n    #elif USE_TEXTURE\n  vec4 texture_tmp = texture(texture, uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture(texture, uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n    #endif\n    return o;\n  }\n  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n  float snoise(vec2 v) {\n      const vec4 C = vec4(0.211324865405187,\n                          0.366025403784439,\n                          -0.577350269189626,\n                          0.024390243902439);\n      vec2 i  = floor(v + dot(v, C.yy));\n      vec2 x0 = v - i + dot(i, C.xx);\n      vec2 i1 = vec2(0.0);\n      i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n      vec2 x1 = x0.xy + C.xx - i1;\n      vec2 x2 = x0.xy + C.zz;\n      i = mod289(i);\n      vec3 p = permute(\n              permute( i.y + vec3(0.0, i1.y, 1.0))\n                  + i.x + vec3(0.0, i1.x, 1.0 ));\n      vec3 m = max(0.5 - vec3(\n                          dot(x0,x0),\n                          dot(x1,x1),\n                          dot(x2,x2)\n                          ), 0.0);\n      m = m*m ;\n      m = m*m ;\n      vec3 x = 2.0 * fract(p * C.www) - 1.0;\n      vec3 h = abs(x) - 0.5;\n      vec3 ox = floor(x + 0.5);\n      vec3 a0 = x - ox;\n      m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n      vec3 g = vec3(0.0);\n      g.x  = a0.x  * x0.x  + h.x  * x0.y;\n      g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n      return 130.0 * dot(m, g);\n  }\nvec4 drawLines(vec2 mn, vec2 uv, float scale) {\n    uv.y += cc_time.x * lineSpeed * scale / selfRect.w;\n    uv *= mn / scale;\n    float noise = snoise(uv);\n    noise = (1.0 + noise) * 0.5;\n    float value = smoothstep(a1, b1, noise);\n    vec4 lines = vec4(color1.xyz, value);\n    value = smoothstep(a2, b2, noise);\n    lines.xyz += (color2.xyz * color2.w) * value;\n    return lines;\n}\n  void main () {\n    vec4 o = getColor(v_uv0);\n    vec2 realUV0 = (v_uv0 - selfXYWH.xy) / selfXYWH.zw;\n    vec2 realUV = realUV0;\n#if USE_SLICE\n    realUV = ((realUV - 0.0) / (spSlice.xy - 0.0) * (selfSlice.xy - 0.0) + 0.0) * step(realUV, spSlice.xy)\n      + ((realUV - spSlice.xy) / (spSlice.zw - spSlice.xy) * (selfSlice.zw - selfSlice.xy) + selfSlice.xy) * (step(spSlice.xy, realUV) - step(spSlice.zw, realUV))\n      + ((realUV - spSlice.zw) / (1.0 - spSlice.zw) * (1.0 - selfSlice.zw) + selfSlice.zw) * step(spSlice.zw, realUV.xy)\n    ;\n#endif\n    vec2 mn = selfRect.zw / vec2(lineW, lineH);\n    vec4 _o = drawLines(mn, realUV, 1.0);\n    _o.w *= ((smoothstep(0.0, 0.2, realUV.x) - smoothstep(0.8, 1.0, realUV.x))) * ((smoothstep(0.0, 0.2, realUV.y) - smoothstep(0.8, 1.0, realUV.y)));\n    #if SHOW_TARGET\n      o.xyz += _o.xyz * _o.w;\n    #else\n      o.xyz = _o.xyz;\n      o.a *= _o.w;\n    #endif\n    o *= v_color;\n    ALPHA_TEST(o);\n    gl_FragColor = o;\n  }"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform vec4 cc_time;\n  varying vec4 v_color;\n  #if USE_TEXTURE\n  varying vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\n  #if USE_TARGET\n  uniform sampler2D targetTex;\n  #endif\n  uniform vec4 targetXYWH;\nuniform vec4 targetRect;\nuniform vec4 selfXYWH;\nuniform vec4 selfRect;\nuniform vec4 spSlice;\nuniform vec4 selfSlice;\nuniform vec4 color1;\nuniform vec4 color2;\nuniform float lineW;\nuniform float lineH;\nuniform float lineSpeed;\nuniform float a1;\nuniform float b1;\nuniform float a2;\nuniform float b2;\n  vec4 getColor(vec2 uv0) {\n    vec4 o = vec4(1, 1, 1, 1);\n    #if USE_TARGET\n  vec4 targetTex_tmp = texture2D(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw);\n  #if CC_USE_ALPHA_ATLAS_targetTex\n      targetTex_tmp.a *= texture2D(targetTex, (targetXYWH.xy + (targetRect.zw - selfRect.zw) / 2.0 / targetRect.zw * targetXYWH.zw + uv0 * targetXYWH.zw * selfRect.zw / targetRect.zw - selfXYWH.xy) / selfXYWH.zw + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (targetTex_tmp.rgb * targetTex_tmp.rgb);\n    o.a *= targetTex_tmp.a;\n  #else\n    o *= targetTex_tmp;\n  #endif\n    #elif USE_TEXTURE\n  vec4 texture_tmp = texture2D(texture, uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture2D(texture, uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n    #endif\n    return o;\n  }\n  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n  float snoise(vec2 v) {\n      const vec4 C = vec4(0.211324865405187,\n                          0.366025403784439,\n                          -0.577350269189626,\n                          0.024390243902439);\n      vec2 i  = floor(v + dot(v, C.yy));\n      vec2 x0 = v - i + dot(i, C.xx);\n      vec2 i1 = vec2(0.0);\n      i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n      vec2 x1 = x0.xy + C.xx - i1;\n      vec2 x2 = x0.xy + C.zz;\n      i = mod289(i);\n      vec3 p = permute(\n              permute( i.y + vec3(0.0, i1.y, 1.0))\n                  + i.x + vec3(0.0, i1.x, 1.0 ));\n      vec3 m = max(0.5 - vec3(\n                          dot(x0,x0),\n                          dot(x1,x1),\n                          dot(x2,x2)\n                          ), 0.0);\n      m = m*m ;\n      m = m*m ;\n      vec3 x = 2.0 * fract(p * C.www) - 1.0;\n      vec3 h = abs(x) - 0.5;\n      vec3 ox = floor(x + 0.5);\n      vec3 a0 = x - ox;\n      m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n      vec3 g = vec3(0.0);\n      g.x  = a0.x  * x0.x  + h.x  * x0.y;\n      g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n      return 130.0 * dot(m, g);\n  }\nvec4 drawLines(vec2 mn, vec2 uv, float scale) {\n    uv.y += cc_time.x * lineSpeed * scale / selfRect.w;\n    uv *= mn / scale;\n    float noise = snoise(uv);\n    noise = (1.0 + noise) * 0.5;\n    float value = smoothstep(a1, b1, noise);\n    vec4 lines = vec4(color1.xyz, value);\n    value = smoothstep(a2, b2, noise);\n    lines.xyz += (color2.xyz * color2.w) * value;\n    return lines;\n}\n  void main () {\n    vec4 o = getColor(v_uv0);\n    vec2 realUV0 = (v_uv0 - selfXYWH.xy) / selfXYWH.zw;\n    vec2 realUV = realUV0;\n#if USE_SLICE\n    realUV = ((realUV - 0.0) / (spSlice.xy - 0.0) * (selfSlice.xy - 0.0) + 0.0) * step(realUV, spSlice.xy)\n      + ((realUV - spSlice.xy) / (spSlice.zw - spSlice.xy) * (selfSlice.zw - selfSlice.xy) + selfSlice.xy) * (step(spSlice.xy, realUV) - step(spSlice.zw, realUV))\n      + ((realUV - spSlice.zw) / (1.0 - spSlice.zw) * (1.0 - selfSlice.zw) + selfSlice.zw) * step(spSlice.zw, realUV.xy)\n    ;\n#endif\n    vec2 mn = selfRect.zw / vec2(lineW, lineH);\n    vec4 _o = drawLines(mn, realUV, 1.0);\n    _o.w *= ((smoothstep(0.0, 0.2, realUV.x) - smoothstep(0.8, 1.0, realUV.x))) * ((smoothstep(0.0, 0.2, realUV.y) - smoothstep(0.8, 1.0, realUV.y)));\n    #if SHOW_TARGET\n      o.xyz += _o.xyz * _o.w;\n    #else\n      o.xyz = _o.xyz;\n      o.a *= _o.w;\n    #endif\n    o *= v_color;\n    ALPHA_TEST(o);\n    gl_FragColor = o;\n  }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"USE_TARGET","type":"boolean","defines":[]},{"name":"CC_USE_ALPHA_ATLAS_targetTex","type":"boolean","defines":["USE_TARGET"]},{"name":"INPUT_IS_GAMMA","type":"boolean","defines":["USE_TARGET"]},{"name":"CC_USE_ALPHA_ATLAS_texture","type":"boolean","defines":["USE_TEXTURE"]},{"name":"USE_SLICE","type":"boolean","defines":[]},{"name":"SHOW_TARGET","type":"boolean","defines":[]}],"blocks":[{"name":"ALPHA_TEST","binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"ubo","binding":1,"members":[{"name":"targetXYWH","type":16,"count":1},{"name":"targetRect","type":16,"count":1},{"name":"selfXYWH","type":16,"count":1},{"name":"selfRect","type":16,"count":1},{"name":"spSlice","type":16,"count":1},{"name":"selfSlice","type":16,"count":1},{"name":"color1","type":16,"count":1},{"name":"color2","type":16,"count":1},{"name":"ran","type":13,"count":1},{"name":"lineW","type":13,"count":1},{"name":"lineH","type":13,"count":1},{"name":"lineSpeed","type":13,"count":1},{"name":"a1","type":13,"count":1},{"name":"b1","type":13,"count":1},{"name":"a2","type":13,"count":1},{"name":"b2","type":13,"count":1}],"defines":[]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]},{"name":"targetTex","type":29,"count":1,"binding":31,"defines":["USE_TARGET"]}]}],[{"passes":[{"program":"BUFF|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"targetTex":{"value":"white","type":29},"alphaThreshold":{"type":13,"value":[0.5]},"selfXYWH":{"type":16,"value":[0,0,1,1]},"selfRect":{"type":16,"value":[0,0,256,256]},"spSlice":{"type":16,"value":[0,0,1,1]},"selfSlice":{"type":16,"value":[0,0,1,1]},"targetXYWH":{"type":16,"value":[0,0,1,1]},"targetRect":{"type":16,"value":[0,0,256,256]},"ran":{"type":13,"value":[0],"editor":{"tooltip":"随机数 [0, 1)","range":[0,1]}},"color1":{"type":16,"value":[1,0.3,0,1],"editor":{"type":"color"}},"color2":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"lineW":{"type":13,"value":[10],"editor":{"tooltip":"扫光宽（像素）","range":[0,100]}},"lineH":{"type":13,"value":[200],"editor":{"tooltip":"扫光高（像素）","range":[0,500]}},"lineSpeed":{"type":13,"value":[300],"editor":{"tooltip":"扫光速度（像素/秒）","range":[0,1000]}},"a1":{"type":13,"value":[0.4],"editor":{"tooltip":"color1的smoothstep参数A","range":[0,1]}},"b1":{"type":13,"value":[1],"editor":{"tooltip":"color1的smoothstep参数B","range":[0,1]}},"a2":{"type":13,"value":[0.6],"editor":{"tooltip":"color2的smoothstep参数A","range":[0,1]}},"b2":{"type":13,"value":[1],"editor":{"tooltip":"color2的smoothstep参数B","range":[0,1]}}}}]}]]],0,0,[],[],[]],[[[1,"BUFF",{"0":{"defines":{"USE_TEXTURE":true}}}]],0,0,[0],[0],[0]]]]